// Code generated by protoc-gen-go. DO NOT EDIT.
// source: invoicerpc/invoice.proto

/*
Package invoicerpc is a generated protocol buffer package.

It is generated from these files:
	invoicerpc/invoice.proto

It has these top-level messages:
	Invoice
	AddInvoiceResponse
	ListInvoiceRequest
	ListInvoiceResponse
	InvoiceSubscription
*/
package invoicerpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import lnrpc "github.com/lightningnetwork/lnd/lnrpc"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Invoice struct {
	// *
	// An optional memo to attach along with the invoice. Used for record keeping
	// purposes for the invoice's creator, and will also be set in the description
	// field of the encoded payment request if the description_hash field is not
	// being used.
	Memo string `protobuf:"bytes,1,opt,name=memo" json:"memo,omitempty"`
	// / An optional cryptographic receipt of payment
	Receipt []byte `protobuf:"bytes,2,opt,name=receipt,proto3" json:"receipt,omitempty"`
	// *
	// The hex-encoded preimage (32 byte) which will allow settling an incoming
	// HTLC payable to this preimage
	RPreimage []byte `protobuf:"bytes,3,opt,name=r_preimage,json=rPreimage,proto3" json:"r_preimage,omitempty"`
	// / The hash of the preimage
	RHash []byte `protobuf:"bytes,4,opt,name=r_hash,json=rHash,proto3" json:"r_hash,omitempty"`
	// / The value of this invoice in satoshis
	Value int64 `protobuf:"varint,5,opt,name=value" json:"value,omitempty"`
	// / Whether this invoice has been fulfilled
	Settled bool `protobuf:"varint,6,opt,name=settled" json:"settled,omitempty"`
	// / When this invoice was created
	CreationDate int64 `protobuf:"varint,7,opt,name=creation_date,json=creationDate" json:"creation_date,omitempty"`
	// / When this invoice was settled
	SettleDate int64 `protobuf:"varint,8,opt,name=settle_date,json=settleDate" json:"settle_date,omitempty"`
	// *
	// A bare-bones invoice for a payment within the Lightning Network.  With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	PaymentRequest string `protobuf:"bytes,9,opt,name=payment_request,json=paymentRequest" json:"payment_request,omitempty"`
	// *
	// Hash (SHA-256) of a description of the payment. Used if the description of
	// payment (memo) is too long to naturally fit within the description field
	// of an encoded payment request.
	DescriptionHash []byte `protobuf:"bytes,10,opt,name=description_hash,json=descriptionHash,proto3" json:"description_hash,omitempty"`
	// / Payment request expiry time in seconds. Default is 3600 (1 hour).
	Expiry int64 `protobuf:"varint,11,opt,name=expiry" json:"expiry,omitempty"`
	// / Fallback on-chain address.
	FallbackAddr string `protobuf:"bytes,12,opt,name=fallback_addr,json=fallbackAddr" json:"fallback_addr,omitempty"`
	// / Delta to use for the time-lock of the CLTV extended to the final hop.
	CltvExpiry uint64 `protobuf:"varint,13,opt,name=cltv_expiry,json=cltvExpiry" json:"cltv_expiry,omitempty"`
	// *
	// Route hints that can each be individually used to assist in reaching the
	// invoice's destination.
	RouteHints []*lnrpc.RouteHint `protobuf:"bytes,14,rep,name=route_hints,json=routeHints" json:"route_hints,omitempty"`
	// / Whether this invoice should include routing hints for private channels.
	Private bool `protobuf:"varint,15,opt,name=private" json:"private,omitempty"`
	// *
	// The "add" index of this invoice. Each newly created invoice will increment
	// this index making it monotonically increasing. Callers to the
	// SubscribeInvoices call can use this to instantly get notified of all added
	// invoices with an add_index greater than this one.
	AddIndex uint64 `protobuf:"varint,16,opt,name=add_index,json=addIndex" json:"add_index,omitempty"`
	// *
	// The "settle" index of this invoice. Each newly settled invoice will
	// increment this index making it monotonically increasing. Callers to the
	// SubscribeInvoices call can use this to instantly get notified of all
	// settled invoices with an settle_index greater than this one.
	SettleIndex uint64 `protobuf:"varint,17,opt,name=settle_index,json=settleIndex" json:"settle_index,omitempty"`
	// / Deprecated, use amt_paid_sat or amt_paid_msat.
	AmtPaid int64 `protobuf:"varint,18,opt,name=amt_paid,json=amtPaid" json:"amt_paid,omitempty"`
	// *
	// The amount that was accepted for this invoice, in satoshis. This will ONLY
	// be set if this invoice has been settled. We provide this field as if the
	// invoice was created with a zero value, then we need to record what amount
	// was ultimately accepted. Additionally, it's possible that the sender paid
	// MORE that was specified in the original invoice. So we'll record that here
	// as well.
	AmtPaidSat int64 `protobuf:"varint,19,opt,name=amt_paid_sat,json=amtPaidSat" json:"amt_paid_sat,omitempty"`
	// *
	// The amount that was accepted for this invoice, in millisatoshis. This will
	// ONLY be set if this invoice has been settled. We provide this field as if
	// the invoice was created with a zero value, then we need to record what
	// amount was ultimately accepted. Additionally, it's possible that the sender
	// paid MORE that was specified in the original invoice. So we'll record that
	// here as well.
	AmtPaidMsat int64 `protobuf:"varint,20,opt,name=amt_paid_msat,json=amtPaidMsat" json:"amt_paid_msat,omitempty"`
}

func (m *Invoice) Reset()                    { *m = Invoice{} }
func (m *Invoice) String() string            { return proto.CompactTextString(m) }
func (*Invoice) ProtoMessage()               {}
func (*Invoice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Invoice) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *Invoice) GetReceipt() []byte {
	if m != nil {
		return m.Receipt
	}
	return nil
}

func (m *Invoice) GetRPreimage() []byte {
	if m != nil {
		return m.RPreimage
	}
	return nil
}

func (m *Invoice) GetRHash() []byte {
	if m != nil {
		return m.RHash
	}
	return nil
}

func (m *Invoice) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Invoice) GetSettled() bool {
	if m != nil {
		return m.Settled
	}
	return false
}

func (m *Invoice) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

func (m *Invoice) GetSettleDate() int64 {
	if m != nil {
		return m.SettleDate
	}
	return 0
}

func (m *Invoice) GetPaymentRequest() string {
	if m != nil {
		return m.PaymentRequest
	}
	return ""
}

func (m *Invoice) GetDescriptionHash() []byte {
	if m != nil {
		return m.DescriptionHash
	}
	return nil
}

func (m *Invoice) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *Invoice) GetFallbackAddr() string {
	if m != nil {
		return m.FallbackAddr
	}
	return ""
}

func (m *Invoice) GetCltvExpiry() uint64 {
	if m != nil {
		return m.CltvExpiry
	}
	return 0
}

func (m *Invoice) GetRouteHints() []*lnrpc.RouteHint {
	if m != nil {
		return m.RouteHints
	}
	return nil
}

func (m *Invoice) GetPrivate() bool {
	if m != nil {
		return m.Private
	}
	return false
}

func (m *Invoice) GetAddIndex() uint64 {
	if m != nil {
		return m.AddIndex
	}
	return 0
}

func (m *Invoice) GetSettleIndex() uint64 {
	if m != nil {
		return m.SettleIndex
	}
	return 0
}

func (m *Invoice) GetAmtPaid() int64 {
	if m != nil {
		return m.AmtPaid
	}
	return 0
}

func (m *Invoice) GetAmtPaidSat() int64 {
	if m != nil {
		return m.AmtPaidSat
	}
	return 0
}

func (m *Invoice) GetAmtPaidMsat() int64 {
	if m != nil {
		return m.AmtPaidMsat
	}
	return 0
}

type AddInvoiceResponse struct {
	RHash []byte `protobuf:"bytes,1,opt,name=r_hash,json=rHash,proto3" json:"r_hash,omitempty"`
	// *
	// A bare-bones invoice for a payment within the Lightning Network.  With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	PaymentRequest string `protobuf:"bytes,2,opt,name=payment_request,json=paymentRequest" json:"payment_request,omitempty"`
	// *
	// The "add" index of this invoice. Each newly created invoice will increment
	// this index making it monotonically increasing. Callers to the
	// SubscribeInvoices call can use this to instantly get notified of all added
	// invoices with an add_index greater than this one.
	AddIndex uint64 `protobuf:"varint,16,opt,name=add_index,json=addIndex" json:"add_index,omitempty"`
}

func (m *AddInvoiceResponse) Reset()                    { *m = AddInvoiceResponse{} }
func (m *AddInvoiceResponse) String() string            { return proto.CompactTextString(m) }
func (*AddInvoiceResponse) ProtoMessage()               {}
func (*AddInvoiceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AddInvoiceResponse) GetRHash() []byte {
	if m != nil {
		return m.RHash
	}
	return nil
}

func (m *AddInvoiceResponse) GetPaymentRequest() string {
	if m != nil {
		return m.PaymentRequest
	}
	return ""
}

func (m *AddInvoiceResponse) GetAddIndex() uint64 {
	if m != nil {
		return m.AddIndex
	}
	return 0
}

type ListInvoiceRequest struct {
	// / If set, only unsettled invoices will be returned in the response.
	PendingOnly bool `protobuf:"varint,1,opt,name=pending_only" json:"pending_only,omitempty"`
	// *
	// The index of an invoice that will be used as either the start or end of a
	// query to determine which invoices should be returned in the response.
	IndexOffset uint64 `protobuf:"varint,4,opt,name=index_offset" json:"index_offset,omitempty"`
	// / The max number of invoices to return in the response to this query.
	NumMaxInvoices uint64 `protobuf:"varint,5,opt,name=num_max_invoices" json:"num_max_invoices,omitempty"`
	// *
	// If set, the invoices returned will result from seeking backwards from the
	// specified index offset. This can be used to paginate backwards.
	Reversed bool `protobuf:"varint,6,opt,name=reversed" json:"reversed,omitempty"`
}

func (m *ListInvoiceRequest) Reset()                    { *m = ListInvoiceRequest{} }
func (m *ListInvoiceRequest) String() string            { return proto.CompactTextString(m) }
func (*ListInvoiceRequest) ProtoMessage()               {}
func (*ListInvoiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ListInvoiceRequest) GetPendingOnly() bool {
	if m != nil {
		return m.PendingOnly
	}
	return false
}

func (m *ListInvoiceRequest) GetIndexOffset() uint64 {
	if m != nil {
		return m.IndexOffset
	}
	return 0
}

func (m *ListInvoiceRequest) GetNumMaxInvoices() uint64 {
	if m != nil {
		return m.NumMaxInvoices
	}
	return 0
}

func (m *ListInvoiceRequest) GetReversed() bool {
	if m != nil {
		return m.Reversed
	}
	return false
}

type ListInvoiceResponse struct {
	// *
	// A list of invoices from the time slice of the time series specified in the
	// request.
	Invoices []*Invoice `protobuf:"bytes,1,rep,name=invoices" json:"invoices,omitempty"`
	// *
	// The index of the last item in the set of returned invoices. This can be used
	// to seek further, pagination style.
	LastIndexOffset uint64 `protobuf:"varint,2,opt,name=last_index_offset" json:"last_index_offset,omitempty"`
	// *
	// The index of the last item in the set of returned invoices. This can be used
	// to seek backwards, pagination style.
	FirstIndexOffset uint64 `protobuf:"varint,3,opt,name=first_index_offset" json:"first_index_offset,omitempty"`
}

func (m *ListInvoiceResponse) Reset()                    { *m = ListInvoiceResponse{} }
func (m *ListInvoiceResponse) String() string            { return proto.CompactTextString(m) }
func (*ListInvoiceResponse) ProtoMessage()               {}
func (*ListInvoiceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ListInvoiceResponse) GetInvoices() []*Invoice {
	if m != nil {
		return m.Invoices
	}
	return nil
}

func (m *ListInvoiceResponse) GetLastIndexOffset() uint64 {
	if m != nil {
		return m.LastIndexOffset
	}
	return 0
}

func (m *ListInvoiceResponse) GetFirstIndexOffset() uint64 {
	if m != nil {
		return m.FirstIndexOffset
	}
	return 0
}

type InvoiceSubscription struct {
	// *
	// If specified (non-zero), then we'll first start by sending out
	// notifications for all added indexes with an add_index greater than this
	// value. This allows callers to catch up on any events they missed while they
	// weren't connected to the streaming RPC.
	AddIndex uint64 `protobuf:"varint,1,opt,name=add_index,json=addIndex" json:"add_index,omitempty"`
	// *
	// If specified (non-zero), then we'll first start by sending out
	// notifications for all settled indexes with an settle_index greater than
	// this value. This allows callers to catch up on any events they missed while
	// they weren't connected to the streaming RPC.
	SettleIndex uint64 `protobuf:"varint,2,opt,name=settle_index,json=settleIndex" json:"settle_index,omitempty"`
}

func (m *InvoiceSubscription) Reset()                    { *m = InvoiceSubscription{} }
func (m *InvoiceSubscription) String() string            { return proto.CompactTextString(m) }
func (*InvoiceSubscription) ProtoMessage()               {}
func (*InvoiceSubscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *InvoiceSubscription) GetAddIndex() uint64 {
	if m != nil {
		return m.AddIndex
	}
	return 0
}

func (m *InvoiceSubscription) GetSettleIndex() uint64 {
	if m != nil {
		return m.SettleIndex
	}
	return 0
}

func init() {
	proto.RegisterType((*Invoice)(nil), "invoicerpc.Invoice")
	proto.RegisterType((*AddInvoiceResponse)(nil), "invoicerpc.AddInvoiceResponse")
	proto.RegisterType((*ListInvoiceRequest)(nil), "invoicerpc.ListInvoiceRequest")
	proto.RegisterType((*ListInvoiceResponse)(nil), "invoicerpc.ListInvoiceResponse")
	proto.RegisterType((*InvoiceSubscription)(nil), "invoicerpc.InvoiceSubscription")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Invoices service

type InvoicesClient interface {
	// * lncli: `addinvoice`
	// AddInvoice attempts to add a new invoice to the invoice database. Any
	// duplicated invoices are rejected, therefore all invoices *must* have a
	// unique payment preimage.
	AddInvoice(ctx context.Context, in *Invoice, opts ...grpc.CallOption) (*AddInvoiceResponse, error)
	// * lncli: `listinvoices`
	// ListInvoices returns a list of all the invoices currently stored within the
	// database. Any active debug invoices are ignored. It has full support for
	// paginated responses, allowing users to query for specific invoices through
	// their add_index. This can be done by using either the first_index_offset or
	// last_index_offset fields included in the response as the index_offset of the
	// next request. The reversed flag is set by default in order to paginate
	// backwards. If you wish to paginate forwards, you must explicitly set the
	// flag to false. If none of the parameters are specified, then the last 100
	// invoices will be returned.
	ListInvoices(ctx context.Context, in *ListInvoiceRequest, opts ...grpc.CallOption) (*ListInvoiceResponse, error)
	// * lncli: `lookupinvoice`
	// LookupInvoice attempts to look up an invoice according to its payment hash.
	// The passed payment hash *must* be exactly 32 bytes, if not, an error is
	// returned.
	LookupInvoice(ctx context.Context, in *lnrpc.PaymentHash, opts ...grpc.CallOption) (*Invoice, error)
	// *
	// SubscribeInvoices returns a uni-directional stream (server -> client) for
	// notifying the client of newly added/settled invoices. The caller can
	// optionally specify the add_index and/or the settle_index. If the add_index
	// is specified, then we'll first start by sending add invoice events for all
	// invoices with an add_index greater than the specified value.  If the
	// settle_index is specified, the next, we'll send out all settle events for
	// invoices with a settle_index greater than the specified value.  One or both
	// of these fields can be set. If no fields are set, then we'll only send out
	// the latest add/settle events.
	SubscribeInvoices(ctx context.Context, in *InvoiceSubscription, opts ...grpc.CallOption) (Invoices_SubscribeInvoicesClient, error)
}

type invoicesClient struct {
	cc *grpc.ClientConn
}

func NewInvoicesClient(cc *grpc.ClientConn) InvoicesClient {
	return &invoicesClient{cc}
}

func (c *invoicesClient) AddInvoice(ctx context.Context, in *Invoice, opts ...grpc.CallOption) (*AddInvoiceResponse, error) {
	out := new(AddInvoiceResponse)
	err := grpc.Invoke(ctx, "/invoicerpc.Invoices/AddInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) ListInvoices(ctx context.Context, in *ListInvoiceRequest, opts ...grpc.CallOption) (*ListInvoiceResponse, error) {
	out := new(ListInvoiceResponse)
	err := grpc.Invoke(ctx, "/invoicerpc.Invoices/ListInvoices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) LookupInvoice(ctx context.Context, in *lnrpc.PaymentHash, opts ...grpc.CallOption) (*Invoice, error) {
	out := new(Invoice)
	err := grpc.Invoke(ctx, "/invoicerpc.Invoices/LookupInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) SubscribeInvoices(ctx context.Context, in *InvoiceSubscription, opts ...grpc.CallOption) (Invoices_SubscribeInvoicesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Invoices_serviceDesc.Streams[0], c.cc, "/invoicerpc.Invoices/SubscribeInvoices", opts...)
	if err != nil {
		return nil, err
	}
	x := &invoicesSubscribeInvoicesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Invoices_SubscribeInvoicesClient interface {
	Recv() (*Invoice, error)
	grpc.ClientStream
}

type invoicesSubscribeInvoicesClient struct {
	grpc.ClientStream
}

func (x *invoicesSubscribeInvoicesClient) Recv() (*Invoice, error) {
	m := new(Invoice)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Invoices service

type InvoicesServer interface {
	// * lncli: `addinvoice`
	// AddInvoice attempts to add a new invoice to the invoice database. Any
	// duplicated invoices are rejected, therefore all invoices *must* have a
	// unique payment preimage.
	AddInvoice(context.Context, *Invoice) (*AddInvoiceResponse, error)
	// * lncli: `listinvoices`
	// ListInvoices returns a list of all the invoices currently stored within the
	// database. Any active debug invoices are ignored. It has full support for
	// paginated responses, allowing users to query for specific invoices through
	// their add_index. This can be done by using either the first_index_offset or
	// last_index_offset fields included in the response as the index_offset of the
	// next request. The reversed flag is set by default in order to paginate
	// backwards. If you wish to paginate forwards, you must explicitly set the
	// flag to false. If none of the parameters are specified, then the last 100
	// invoices will be returned.
	ListInvoices(context.Context, *ListInvoiceRequest) (*ListInvoiceResponse, error)
	// * lncli: `lookupinvoice`
	// LookupInvoice attempts to look up an invoice according to its payment hash.
	// The passed payment hash *must* be exactly 32 bytes, if not, an error is
	// returned.
	LookupInvoice(context.Context, *lnrpc.PaymentHash) (*Invoice, error)
	// *
	// SubscribeInvoices returns a uni-directional stream (server -> client) for
	// notifying the client of newly added/settled invoices. The caller can
	// optionally specify the add_index and/or the settle_index. If the add_index
	// is specified, then we'll first start by sending add invoice events for all
	// invoices with an add_index greater than the specified value.  If the
	// settle_index is specified, the next, we'll send out all settle events for
	// invoices with a settle_index greater than the specified value.  One or both
	// of these fields can be set. If no fields are set, then we'll only send out
	// the latest add/settle events.
	SubscribeInvoices(*InvoiceSubscription, Invoices_SubscribeInvoicesServer) error
}

func RegisterInvoicesServer(s *grpc.Server, srv InvoicesServer) {
	s.RegisterService(&_Invoices_serviceDesc, srv)
}

func _Invoices_AddInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Invoice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).AddInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/invoicerpc.Invoices/AddInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).AddInvoice(ctx, req.(*Invoice))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_ListInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).ListInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/invoicerpc.Invoices/ListInvoices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).ListInvoices(ctx, req.(*ListInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_LookupInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lnrpc.PaymentHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).LookupInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/invoicerpc.Invoices/LookupInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).LookupInvoice(ctx, req.(*lnrpc.PaymentHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_SubscribeInvoices_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InvoiceSubscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InvoicesServer).SubscribeInvoices(m, &invoicesSubscribeInvoicesServer{stream})
}

type Invoices_SubscribeInvoicesServer interface {
	Send(*Invoice) error
	grpc.ServerStream
}

type invoicesSubscribeInvoicesServer struct {
	grpc.ServerStream
}

func (x *invoicesSubscribeInvoicesServer) Send(m *Invoice) error {
	return x.ServerStream.SendMsg(m)
}

var _Invoices_serviceDesc = grpc.ServiceDesc{
	ServiceName: "invoicerpc.Invoices",
	HandlerType: (*InvoicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddInvoice",
			Handler:    _Invoices_AddInvoice_Handler,
		},
		{
			MethodName: "ListInvoices",
			Handler:    _Invoices_ListInvoices_Handler,
		},
		{
			MethodName: "LookupInvoice",
			Handler:    _Invoices_LookupInvoice_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeInvoices",
			Handler:       _Invoices_SubscribeInvoices_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "invoicerpc/invoice.proto",
}

func init() { proto.RegisterFile("invoicerpc/invoice.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 723 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0x4d, 0x6f, 0xdb, 0x38,
	0x10, 0x8d, 0xfc, 0x29, 0x8f, 0xe5, 0xc4, 0xa1, 0xb3, 0x0b, 0xae, 0x17, 0xbb, 0xf1, 0x6a, 0x0f,
	0xeb, 0x2d, 0x0a, 0xbb, 0x4d, 0x6f, 0xbd, 0x05, 0x6d, 0x81, 0x04, 0x48, 0x80, 0x54, 0x41, 0xcf,
	0x02, 0x2d, 0xd2, 0x36, 0x11, 0x89, 0x52, 0x48, 0xda, 0x4d, 0xce, 0xfd, 0x2b, 0xbd, 0xf6, 0x3f,
	0x16, 0xa2, 0x28, 0xc5, 0xae, 0x9d, 0xf6, 0xa6, 0x79, 0xf3, 0x38, 0xf3, 0x66, 0xf8, 0x44, 0xc0,
	0x5c, 0xac, 0x53, 0x1e, 0x31, 0x99, 0x45, 0x53, 0xfb, 0x39, 0xc9, 0x64, 0xaa, 0x53, 0x04, 0x4f,
	0x99, 0xe1, 0x74, 0xc1, 0xf5, 0x72, 0x35, 0x9b, 0x44, 0x69, 0x32, 0x8d, 0xf9, 0x62, 0xa9, 0x05,
	0x17, 0x0b, 0xc1, 0xf4, 0xe7, 0x54, 0xde, 0x4d, 0x63, 0x41, 0xa7, 0xb1, 0xc8, 0x0b, 0xc8, 0x2c,
	0x2a, 0x0e, 0xfb, 0x5f, 0x9a, 0xd0, 0xbe, 0x2c, 0xce, 0x23, 0x04, 0x8d, 0x84, 0x25, 0x29, 0x76,
	0x46, 0xce, 0xb8, 0x13, 0x98, 0x6f, 0x84, 0xa1, 0x2d, 0x59, 0xc4, 0x78, 0xa6, 0x71, 0x6d, 0xe4,
	0x8c, 0xbd, 0xa0, 0x0c, 0xd1, 0x5f, 0x00, 0x32, 0xcc, 0x24, 0xe3, 0x09, 0x59, 0x30, 0x5c, 0x37,
	0xc9, 0x8e, 0xbc, 0xb1, 0x00, 0xfa, 0x0d, 0x5a, 0x32, 0x5c, 0x12, 0xb5, 0xc4, 0x0d, 0x93, 0x6a,
	0xca, 0x0b, 0xa2, 0x96, 0xe8, 0x04, 0x9a, 0x6b, 0x12, 0xaf, 0x18, 0x6e, 0x8e, 0x9c, 0x71, 0x3d,
	0x28, 0x82, 0xbc, 0x8b, 0x62, 0x5a, 0xc7, 0x8c, 0xe2, 0xd6, 0xc8, 0x19, 0xbb, 0x41, 0x19, 0xa2,
	0x7f, 0xa1, 0x17, 0x49, 0x46, 0x34, 0x4f, 0x45, 0x48, 0x89, 0x66, 0xb8, 0x6d, 0xce, 0x79, 0x25,
	0xf8, 0x9e, 0x68, 0x86, 0x4e, 0xa1, 0x5b, 0xf0, 0x0b, 0x8a, 0x6b, 0x28, 0x50, 0x40, 0x86, 0xf0,
	0x1f, 0x1c, 0x65, 0xe4, 0x31, 0x61, 0x42, 0x87, 0x92, 0xdd, 0xaf, 0x98, 0xd2, 0xb8, 0x63, 0x86,
	0x3c, 0xb4, 0x70, 0x50, 0xa0, 0xe8, 0x7f, 0xe8, 0x53, 0xa6, 0x22, 0xc9, 0x33, 0xd3, 0xd1, 0xe8,
	0x07, 0xa3, 0xff, 0x68, 0x03, 0x37, 0x93, 0xfc, 0x0e, 0x2d, 0xf6, 0x90, 0x71, 0xf9, 0x88, 0xbb,
	0xa6, 0x9f, 0x8d, 0x72, 0xc5, 0x73, 0x12, 0xc7, 0x33, 0x12, 0xdd, 0x85, 0x84, 0x52, 0x89, 0x3d,
	0xd3, 0xc9, 0x2b, 0xc1, 0x73, 0x4a, 0x65, 0xae, 0x38, 0x8a, 0xf5, 0x3a, 0xb4, 0x15, 0x7a, 0x23,
	0x67, 0xdc, 0x08, 0x20, 0x87, 0x3e, 0x14, 0x55, 0x5e, 0x43, 0x57, 0xa6, 0x2b, 0xcd, 0xc2, 0x25,
	0x17, 0x5a, 0xe1, 0xc3, 0x51, 0x7d, 0xdc, 0x3d, 0xeb, 0x4f, 0xcc, 0xf5, 0x4d, 0x82, 0x3c, 0x73,
	0xc1, 0x85, 0x0e, 0x40, 0x96, 0x9f, 0x2a, 0x5f, 0x62, 0x26, 0xf9, 0x3a, 0xdf, 0xc0, 0x51, 0xb1,
	0x44, 0x1b, 0xa2, 0x3f, 0xa1, 0x43, 0x28, 0x0d, 0xb9, 0xa0, 0xec, 0x01, 0xf7, 0x4d, 0x2f, 0x97,
	0x50, 0x7a, 0x99, 0xc7, 0xe8, 0x1f, 0xf0, 0xec, 0xf2, 0x8a, 0xfc, 0xb1, 0xc9, 0xdb, 0x85, 0x16,
	0x94, 0x3f, 0xc0, 0x25, 0x89, 0x0e, 0x33, 0xc2, 0x29, 0x46, 0x66, 0xd8, 0x36, 0x49, 0xf4, 0x0d,
	0xe1, 0x14, 0x8d, 0xc0, 0x2b, 0x53, 0xa1, 0x22, 0x1a, 0x0f, 0x8a, 0xdd, 0xdb, 0xf4, 0x2d, 0xd1,
	0xc8, 0x87, 0x5e, 0xc5, 0x48, 0x72, 0xca, 0x89, 0xa1, 0x74, 0x2d, 0xe5, 0x5a, 0x11, 0xed, 0xdf,
	0x03, 0x3a, 0xcf, 0xf5, 0x18, 0x1f, 0x06, 0x4c, 0x65, 0xa9, 0x50, 0x9b, 0x16, 0x72, 0x36, 0x2d,
	0xb4, 0xe7, 0x32, 0x6b, 0x7b, 0x2f, 0xf3, 0x67, 0x63, 0xfb, 0x5f, 0x1d, 0x40, 0x57, 0x5c, 0xe9,
	0xaa, 0x69, 0x71, 0xc6, 0x07, 0x2f, 0x63, 0x82, 0x72, 0xb1, 0x08, 0x53, 0x11, 0x3f, 0x9a, 0xce,
	0x6e, 0xb0, 0x85, 0xe5, 0x1c, 0x53, 0x33, 0x4c, 0xe7, 0x73, 0xc5, 0xb4, 0x31, 0x78, 0x23, 0xd8,
	0xc2, 0xd0, 0x0b, 0xe8, 0x8b, 0x55, 0x12, 0x26, 0xe4, 0x21, 0xb4, 0xbf, 0xa7, 0x32, 0x96, 0x6f,
	0x04, 0x3b, 0x38, 0x1a, 0x82, 0x2b, 0xd9, 0x9a, 0x49, 0x55, 0xd9, 0xbf, 0x8a, 0x73, 0x99, 0x83,
	0x2d, 0x99, 0x76, 0x37, 0x53, 0x70, 0xab, 0xba, 0x8e, 0x31, 0xc7, 0x60, 0xf2, 0xf4, 0x0e, 0x4c,
	0x4a, 0x7a, 0x45, 0x42, 0x2f, 0xe1, 0x38, 0x26, 0x4a, 0x87, 0x5b, 0xca, 0x6b, 0x46, 0xd1, 0x6e,
	0x02, 0x4d, 0x00, 0xcd, 0xb9, 0xfc, 0x91, 0x5e, 0x37, 0xf4, 0x3d, 0x19, 0xff, 0x13, 0x0c, 0x6c,
	0xcb, 0xdb, 0xd5, 0xac, 0xfa, 0x4f, 0xb6, 0x6f, 0xc0, 0xf9, 0x85, 0xf1, 0x6a, 0x3b, 0xc6, 0x3b,
	0xfb, 0x56, 0x03, 0xf7, 0xb2, 0x9c, 0xe0, 0x1d, 0xc0, 0x93, 0x49, 0xd0, 0xbe, 0x71, 0x87, 0x7f,
	0x6f, 0x82, 0xbb, 0x8e, 0xf2, 0x0f, 0xd0, 0x47, 0xf0, 0x36, 0xd6, 0xa9, 0xd0, 0xd6, 0x89, 0x5d,
	0x3f, 0x0c, 0x4f, 0x9f, 0xcd, 0x57, 0x25, 0xdf, 0x42, 0xef, 0x2a, 0x4d, 0xef, 0x56, 0x59, 0xf5,
	0x8e, 0xda, 0xdf, 0xf4, 0xa6, 0xb0, 0x63, 0x6e, 0xda, 0xe1, 0x3e, 0xb9, 0xfe, 0x01, 0xba, 0x86,
	0x63, 0xbb, 0xb0, 0x19, 0xab, 0x34, 0x9d, 0xee, 0xe1, 0x6e, 0xae, 0xf5, 0x99, 0x62, 0xaf, 0x9c,
	0x59, 0xcb, 0x3c, 0xea, 0x6f, 0xbe, 0x07, 0x00, 0x00, 0xff, 0xff, 0x6e, 0xda, 0x5e, 0x7f, 0x2d,
	0x06, 0x00, 0x00,
}
