// Code generated by protoc-gen-go. DO NOT EDIT.
// source: invoicerpc/invoice.proto

/*
Package invoicerpc is a generated protocol buffer package.

It is generated from these files:
	invoicerpc/invoice.proto

It has these top-level messages:
	AddInvoiceRequest
	Invoice
	InvoiceEvent
	InvoiceDynamicData
	AddInvoiceResponse
	ListInvoiceRequest
	ListInvoiceResponse
	InvoiceSubscription
	SettleInvoiceMsg
	SettleInvoiceResp
	CancelInvoiceMsg
	CancelInvoiceResp
*/
package invoicerpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import lnrpc "github.com/lightningnetwork/lnd/lnrpc"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type InvoiceState int32

const (
	// *
	// Invoice are created in the open state. We have not yet received an htlc
	// or the total value of all received htlcs is less than the invoice
	// amount. No htlc has been settled yet. If the total value of received
	// htlcs reaches the invoice amount, the invoice either moves to ACCEPTED
	// or SETTLED based on the hold invoice field value.
	InvoiceState_OPEN InvoiceState = 0
	// *
	// In the accepted state, we have received one or more htlcs that add up
	// to at least the invoice amount. The htlcs can be accepted by calling
	// the SettleInvoice rpc. When an htlc times out, it may be that the
	// invoice moves back to the open state.
	InvoiceState_ACCEPTED InvoiceState = 1
	// *
	// In the settled state, the invoice isn't payable anymore. We have
	// settled one or more htlcs that add up to at least the invoice amount.
	InvoiceState_SETTLED InvoiceState = 2
	// *
	// In the canceled state, the invoice isn't payable anymore. Any htlcs
	// associated with this invoice have been canceled. An invoice can be
	// canceled using the CancelInvoice rpc or canceled automatically when it
	// expires.
	InvoiceState_CANCELED InvoiceState = 3
)

var InvoiceState_name = map[int32]string{
	0: "OPEN",
	1: "ACCEPTED",
	2: "SETTLED",
	3: "CANCELED",
}
var InvoiceState_value = map[string]int32{
	"OPEN":     0,
	"ACCEPTED": 1,
	"SETTLED":  2,
	"CANCELED": 3,
}

func (x InvoiceState) String() string {
	return proto.EnumName(InvoiceState_name, int32(x))
}
func (InvoiceState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// *
// AddInvoiceRequest is a separate message that contains only the parameters
// required to add a new invoice
type AddInvoiceRequest struct {
	// *
	// An optional memo to attach along with the invoice. Used for record keeping
	// purposes for the invoice's creator, and will also be set in the description
	// field of the encoded payment request if the description_hash field is not
	// being used.
	Memo string `protobuf:"bytes,1,opt,name=memo" json:"memo,omitempty"`
	// *
	// Whether this invoice should be held in the accepted state until a settle rpc
	// comes in. It is allowed to add a hold invoice that already specifies
	// r_preimage or haves lnd generate a preimage.
	Hold bool `protobuf:"varint,2,opt,name=hold" json:"hold,omitempty"`
	// *
	// The hex-encoded preimage (32 byte) which will allow settling an incoming
	// HTLC payable to this preimage. If this field is left empty, a random preimage
	// will be generated.
	RPreimage []byte `protobuf:"bytes,3,opt,name=r_preimage,json=rPreimage,proto3" json:"r_preimage,omitempty"`
	// *
	// The hash of the preimage. Setting this field is only allowed if
	// r_preimage is empty and hold is true. In this case we only know the hash
	// of the invoice, we want to accept the htlc when it comes in and hold
	// on to it until we learn the preimage.
	RHash []byte `protobuf:"bytes,4,opt,name=r_hash,json=rHash,proto3" json:"r_hash,omitempty"`
	// / The value of this invoice in satoshis
	Value int64 `protobuf:"varint,5,opt,name=value" json:"value,omitempty"`
	// * Payment request expiry time in seconds. Default is 3600 (1 hour). When
	// the invoice expires, it is moved to the canceled state. Any accepted but
	// still unsettled htlcs are canceled back.
	Expiry int64 `protobuf:"varint,6,opt,name=expiry" json:"expiry,omitempty"`
	// / Fallback on-chain address.
	FallbackAddr string `protobuf:"bytes,7,opt,name=fallback_addr,json=fallbackAddr" json:"fallback_addr,omitempty"`
	// / Delta to use for the time-lock of the CLTV extended to the final hop.
	CltvExpiry uint64 `protobuf:"varint,8,opt,name=cltv_expiry,json=cltvExpiry" json:"cltv_expiry,omitempty"`
	// *
	// Route hints that can each be individually used to assist in reaching the
	// invoice's destination.
	RouteHints []*lnrpc.RouteHint `protobuf:"bytes,9,rep,name=route_hints,json=routeHints" json:"route_hints,omitempty"`
	// / Whether this invoice should include routing hints for private channels.
	Private bool `protobuf:"varint,10,opt,name=private" json:"private,omitempty"`
}

func (m *AddInvoiceRequest) Reset()                    { *m = AddInvoiceRequest{} }
func (m *AddInvoiceRequest) String() string            { return proto.CompactTextString(m) }
func (*AddInvoiceRequest) ProtoMessage()               {}
func (*AddInvoiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AddInvoiceRequest) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *AddInvoiceRequest) GetHold() bool {
	if m != nil {
		return m.Hold
	}
	return false
}

func (m *AddInvoiceRequest) GetRPreimage() []byte {
	if m != nil {
		return m.RPreimage
	}
	return nil
}

func (m *AddInvoiceRequest) GetRHash() []byte {
	if m != nil {
		return m.RHash
	}
	return nil
}

func (m *AddInvoiceRequest) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *AddInvoiceRequest) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *AddInvoiceRequest) GetFallbackAddr() string {
	if m != nil {
		return m.FallbackAddr
	}
	return ""
}

func (m *AddInvoiceRequest) GetCltvExpiry() uint64 {
	if m != nil {
		return m.CltvExpiry
	}
	return 0
}

func (m *AddInvoiceRequest) GetRouteHints() []*lnrpc.RouteHint {
	if m != nil {
		return m.RouteHints
	}
	return nil
}

func (m *AddInvoiceRequest) GetPrivate() bool {
	if m != nil {
		return m.Private
	}
	return false
}

type Invoice struct {
	// *
	// An optional memo to attach along with the invoice. Used for record keeping
	// purposes for the invoice's creator, and will also be set in the description
	// field of the encoded payment request if the description_hash field is not
	// being used.
	Memo string `protobuf:"bytes,1,opt,name=memo" json:"memo,omitempty"`
	// / The hash of the preimage
	RHash []byte `protobuf:"bytes,3,opt,name=r_hash,json=rHash,proto3" json:"r_hash,omitempty"`
	// / The value of this invoice in satoshis
	Value int64 `protobuf:"varint,4,opt,name=value" json:"value,omitempty"`
	// / When this invoice was created
	CreationDate int64 `protobuf:"varint,5,opt,name=creation_date,json=creationDate" json:"creation_date,omitempty"`
	// *
	// A bare-bones invoice for a payment within the Lightning Network.  With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	PaymentRequest string `protobuf:"bytes,7,opt,name=payment_request,json=paymentRequest" json:"payment_request,omitempty"`
	// / Payment request expiry time in seconds. Default is 3600 (1 hour).
	Expiry int64 `protobuf:"varint,8,opt,name=expiry" json:"expiry,omitempty"`
	// / Fallback on-chain address.
	FallbackAddr string `protobuf:"bytes,9,opt,name=fallback_addr,json=fallbackAddr" json:"fallback_addr,omitempty"`
	// / Delta to use for the time-lock of the CLTV extended to the final hop.
	CltvExpiry uint64 `protobuf:"varint,10,opt,name=cltv_expiry,json=cltvExpiry" json:"cltv_expiry,omitempty"`
	// *
	// Route hints that can each be individually used to assist in reaching the
	// invoice's destination.
	RouteHints []*lnrpc.RouteHint `protobuf:"bytes,11,rep,name=route_hints,json=routeHints" json:"route_hints,omitempty"`
	// / Whether this invoice should include routing hints for private channels.
	Private bool `protobuf:"varint,12,opt,name=private" json:"private,omitempty"`
	// *
	// The number of this invoice. Each newly created invoice will increment
	// this number making it monotonically increasing.
	InvoiceNumber uint64 `protobuf:"varint,13,opt,name=invoice_number,json=invoiceNumber" json:"invoice_number,omitempty"`
	// *
	// A snapshot of the most recent invoice dynamic data.
	DynamicData *InvoiceDynamicData `protobuf:"bytes,14,opt,name=dynamic_data,json=dynamicData" json:"dynamic_data,omitempty"`
}

func (m *Invoice) Reset()                    { *m = Invoice{} }
func (m *Invoice) String() string            { return proto.CompactTextString(m) }
func (*Invoice) ProtoMessage()               {}
func (*Invoice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Invoice) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *Invoice) GetRHash() []byte {
	if m != nil {
		return m.RHash
	}
	return nil
}

func (m *Invoice) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Invoice) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

func (m *Invoice) GetPaymentRequest() string {
	if m != nil {
		return m.PaymentRequest
	}
	return ""
}

func (m *Invoice) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *Invoice) GetFallbackAddr() string {
	if m != nil {
		return m.FallbackAddr
	}
	return ""
}

func (m *Invoice) GetCltvExpiry() uint64 {
	if m != nil {
		return m.CltvExpiry
	}
	return 0
}

func (m *Invoice) GetRouteHints() []*lnrpc.RouteHint {
	if m != nil {
		return m.RouteHints
	}
	return nil
}

func (m *Invoice) GetPrivate() bool {
	if m != nil {
		return m.Private
	}
	return false
}

func (m *Invoice) GetInvoiceNumber() uint64 {
	if m != nil {
		return m.InvoiceNumber
	}
	return 0
}

func (m *Invoice) GetDynamicData() *InvoiceDynamicData {
	if m != nil {
		return m.DynamicData
	}
	return nil
}

type InvoiceEvent struct {
	// *
	// The number of this invoice. Each newly created invoice will increment
	// this number making it monotonically increasing.
	InvoiceNumber uint64 `protobuf:"varint,1,opt,name=invoice_number,json=invoiceNumber" json:"invoice_number,omitempty"`
	// *
	// A snapshot of the invoice dynamic data.
	DynamicData *InvoiceDynamicData `protobuf:"bytes,2,opt,name=dynamic_data,json=dynamicData" json:"dynamic_data,omitempty"`
}

func (m *InvoiceEvent) Reset()                    { *m = InvoiceEvent{} }
func (m *InvoiceEvent) String() string            { return proto.CompactTextString(m) }
func (*InvoiceEvent) ProtoMessage()               {}
func (*InvoiceEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *InvoiceEvent) GetInvoiceNumber() uint64 {
	if m != nil {
		return m.InvoiceNumber
	}
	return 0
}

func (m *InvoiceEvent) GetDynamicData() *InvoiceDynamicData {
	if m != nil {
		return m.DynamicData
	}
	return nil
}

type InvoiceDynamicData struct {
	State InvoiceState `protobuf:"varint,1,opt,name=state,enum=invoicerpc.InvoiceState" json:"state,omitempty"`
	// *
	// The hex-encoded preimage (32 byte) which will allow settling an incoming
	// HTLC payable to this preimage.
	//
	// Preimage is part of the event stream because it doesn't necessarily need to
	// be known when the invoice is created.
	RPreimage []byte `protobuf:"bytes,2,opt,name=r_preimage,json=rPreimage,proto3" json:"r_preimage,omitempty"`
	// / When this invoice was settled
	SettleDate int64 `protobuf:"varint,3,opt,name=settle_date,json=settleDate" json:"settle_date,omitempty"`
	// *
	// A system wide index for this particular update of the dynamic data.
	UpdateIndex uint64 `protobuf:"varint,4,opt,name=update_index,json=updateIndex" json:"update_index,omitempty"`
	// *
	// The amount amt_paid_msat rounded down to satoshis
	AmtPaidSat int64 `protobuf:"varint,5,opt,name=amt_paid_sat,json=amtPaidSat" json:"amt_paid_sat,omitempty"`
	// *
	// The amount that was accepted or settled for this invoice, in millisatoshis.
	// This will be set in both the ACCEPTED and SETTLED invoice states.
	//
	// We provide this field as if the invoice was created with a zero value, then
	// we need to record what amount was ultimately accepted. Additionally, it's
	// possible that the sender paid MORE than what was specified in the original
	// invoice. So we'll record that here as well.
	//
	// In the OPEN state, there may be htlc(s) accepted, but their value is not
	// reported (yet). Only when the sum reaches the invoice amount, the invoice
	// moves to ACCEPTED or SETTLED and amt_paid_sat is reported.
	AmtPaidMsat int64 `protobuf:"varint,6,opt,name=amt_paid_msat,json=amtPaidMsat" json:"amt_paid_msat,omitempty"`
}

func (m *InvoiceDynamicData) Reset()                    { *m = InvoiceDynamicData{} }
func (m *InvoiceDynamicData) String() string            { return proto.CompactTextString(m) }
func (*InvoiceDynamicData) ProtoMessage()               {}
func (*InvoiceDynamicData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *InvoiceDynamicData) GetState() InvoiceState {
	if m != nil {
		return m.State
	}
	return InvoiceState_OPEN
}

func (m *InvoiceDynamicData) GetRPreimage() []byte {
	if m != nil {
		return m.RPreimage
	}
	return nil
}

func (m *InvoiceDynamicData) GetSettleDate() int64 {
	if m != nil {
		return m.SettleDate
	}
	return 0
}

func (m *InvoiceDynamicData) GetUpdateIndex() uint64 {
	if m != nil {
		return m.UpdateIndex
	}
	return 0
}

func (m *InvoiceDynamicData) GetAmtPaidSat() int64 {
	if m != nil {
		return m.AmtPaidSat
	}
	return 0
}

func (m *InvoiceDynamicData) GetAmtPaidMsat() int64 {
	if m != nil {
		return m.AmtPaidMsat
	}
	return 0
}

type AddInvoiceResponse struct {
	RHash []byte `protobuf:"bytes,1,opt,name=r_hash,json=rHash,proto3" json:"r_hash,omitempty"`
	// *
	// A bare-bones invoice for a payment within the Lightning Network.  With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	PaymentRequest string `protobuf:"bytes,2,opt,name=payment_request,json=paymentRequest" json:"payment_request,omitempty"`
	// *
	// The number of this invoice. Each newly created invoice will increment
	// this index making it monotonically increasing.
	InvoiceNumber uint64 `protobuf:"varint,3,opt,name=invoice_number,json=invoiceNumber" json:"invoice_number,omitempty"`
}

func (m *AddInvoiceResponse) Reset()                    { *m = AddInvoiceResponse{} }
func (m *AddInvoiceResponse) String() string            { return proto.CompactTextString(m) }
func (*AddInvoiceResponse) ProtoMessage()               {}
func (*AddInvoiceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *AddInvoiceResponse) GetRHash() []byte {
	if m != nil {
		return m.RHash
	}
	return nil
}

func (m *AddInvoiceResponse) GetPaymentRequest() string {
	if m != nil {
		return m.PaymentRequest
	}
	return ""
}

func (m *AddInvoiceResponse) GetInvoiceNumber() uint64 {
	if m != nil {
		return m.InvoiceNumber
	}
	return 0
}

type ListInvoiceRequest struct {
	// / If set, only unsettled invoices will be returned in the response.
	PendingOnly bool `protobuf:"varint,1,opt,name=pending_only" json:"pending_only,omitempty"`
	// *
	// The index of an invoice that will be used as either the start or end of a
	// query to determine which invoices should be returned in the response.
	IndexOffset uint64 `protobuf:"varint,4,opt,name=index_offset" json:"index_offset,omitempty"`
	// / The max number of invoices to return in the response to this query.
	NumMaxInvoices uint64 `protobuf:"varint,5,opt,name=num_max_invoices" json:"num_max_invoices,omitempty"`
	// *
	// If set, the invoices returned will result from seeking backwards from the
	// specified index offset. This can be used to paginate backwards.
	Reversed bool `protobuf:"varint,6,opt,name=reversed" json:"reversed,omitempty"`
}

func (m *ListInvoiceRequest) Reset()                    { *m = ListInvoiceRequest{} }
func (m *ListInvoiceRequest) String() string            { return proto.CompactTextString(m) }
func (*ListInvoiceRequest) ProtoMessage()               {}
func (*ListInvoiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ListInvoiceRequest) GetPendingOnly() bool {
	if m != nil {
		return m.PendingOnly
	}
	return false
}

func (m *ListInvoiceRequest) GetIndexOffset() uint64 {
	if m != nil {
		return m.IndexOffset
	}
	return 0
}

func (m *ListInvoiceRequest) GetNumMaxInvoices() uint64 {
	if m != nil {
		return m.NumMaxInvoices
	}
	return 0
}

func (m *ListInvoiceRequest) GetReversed() bool {
	if m != nil {
		return m.Reversed
	}
	return false
}

type ListInvoiceResponse struct {
	// *
	// A list of invoices from the time slice of the time series specified in the
	// request.
	Invoices []*Invoice `protobuf:"bytes,1,rep,name=invoices" json:"invoices,omitempty"`
	// *
	// The index of the last item in the set of returned invoices. This can be used
	// to seek further, pagination style.
	LastIndexOffset uint64 `protobuf:"varint,2,opt,name=last_index_offset" json:"last_index_offset,omitempty"`
	// *
	// The index of the last item in the set of returned invoices. This can be used
	// to seek backwards, pagination style.
	FirstIndexOffset uint64 `protobuf:"varint,3,opt,name=first_index_offset" json:"first_index_offset,omitempty"`
}

func (m *ListInvoiceResponse) Reset()                    { *m = ListInvoiceResponse{} }
func (m *ListInvoiceResponse) String() string            { return proto.CompactTextString(m) }
func (*ListInvoiceResponse) ProtoMessage()               {}
func (*ListInvoiceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ListInvoiceResponse) GetInvoices() []*Invoice {
	if m != nil {
		return m.Invoices
	}
	return nil
}

func (m *ListInvoiceResponse) GetLastIndexOffset() uint64 {
	if m != nil {
		return m.LastIndexOffset
	}
	return 0
}

func (m *ListInvoiceResponse) GetFirstIndexOffset() uint64 {
	if m != nil {
		return m.FirstIndexOffset
	}
	return 0
}

type InvoiceSubscription struct {
	// *
	// If specified (non-zero), then we'll first start by sending out
	// all invoices that have an last_update_index greater than this value. This allows
	// callers to retrieve up to date versions of invoices that changed when they
	// weren't connected to the streaming RPC.
	LastUpdateIndex uint64 `protobuf:"varint,1,opt,name=last_update_index,json=lastUpdateIndex" json:"last_update_index,omitempty"`
}

func (m *InvoiceSubscription) Reset()                    { *m = InvoiceSubscription{} }
func (m *InvoiceSubscription) String() string            { return proto.CompactTextString(m) }
func (*InvoiceSubscription) ProtoMessage()               {}
func (*InvoiceSubscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *InvoiceSubscription) GetLastUpdateIndex() uint64 {
	if m != nil {
		return m.LastUpdateIndex
	}
	return 0
}

type SettleInvoiceMsg struct {
	// / Hash corresponding to the (hold) invoice to settle.
	PaymentHash []byte `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	// * Optional preimage to settle the invoice with. Only needs to be supplied
	// when lnd isn't aware of the preimage yet. This is the case for an externally
	// discovered preimage.
	PreImage []byte `protobuf:"bytes,2,opt,name=pre_image,json=preImage,proto3" json:"pre_image,omitempty"`
}

func (m *SettleInvoiceMsg) Reset()                    { *m = SettleInvoiceMsg{} }
func (m *SettleInvoiceMsg) String() string            { return proto.CompactTextString(m) }
func (*SettleInvoiceMsg) ProtoMessage()               {}
func (*SettleInvoiceMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SettleInvoiceMsg) GetPaymentHash() []byte {
	if m != nil {
		return m.PaymentHash
	}
	return nil
}

func (m *SettleInvoiceMsg) GetPreImage() []byte {
	if m != nil {
		return m.PreImage
	}
	return nil
}

type SettleInvoiceResp struct {
}

func (m *SettleInvoiceResp) Reset()                    { *m = SettleInvoiceResp{} }
func (m *SettleInvoiceResp) String() string            { return proto.CompactTextString(m) }
func (*SettleInvoiceResp) ProtoMessage()               {}
func (*SettleInvoiceResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type CancelInvoiceMsg struct {
	// / Hash corresponding to the (hold) invoice to fail.
	PaymentHash []byte `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
}

func (m *CancelInvoiceMsg) Reset()                    { *m = CancelInvoiceMsg{} }
func (m *CancelInvoiceMsg) String() string            { return proto.CompactTextString(m) }
func (*CancelInvoiceMsg) ProtoMessage()               {}
func (*CancelInvoiceMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *CancelInvoiceMsg) GetPaymentHash() []byte {
	if m != nil {
		return m.PaymentHash
	}
	return nil
}

type CancelInvoiceResp struct {
}

func (m *CancelInvoiceResp) Reset()                    { *m = CancelInvoiceResp{} }
func (m *CancelInvoiceResp) String() string            { return proto.CompactTextString(m) }
func (*CancelInvoiceResp) ProtoMessage()               {}
func (*CancelInvoiceResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func init() {
	proto.RegisterType((*AddInvoiceRequest)(nil), "invoicerpc.AddInvoiceRequest")
	proto.RegisterType((*Invoice)(nil), "invoicerpc.Invoice")
	proto.RegisterType((*InvoiceEvent)(nil), "invoicerpc.InvoiceEvent")
	proto.RegisterType((*InvoiceDynamicData)(nil), "invoicerpc.InvoiceDynamicData")
	proto.RegisterType((*AddInvoiceResponse)(nil), "invoicerpc.AddInvoiceResponse")
	proto.RegisterType((*ListInvoiceRequest)(nil), "invoicerpc.ListInvoiceRequest")
	proto.RegisterType((*ListInvoiceResponse)(nil), "invoicerpc.ListInvoiceResponse")
	proto.RegisterType((*InvoiceSubscription)(nil), "invoicerpc.InvoiceSubscription")
	proto.RegisterType((*SettleInvoiceMsg)(nil), "invoicerpc.SettleInvoiceMsg")
	proto.RegisterType((*SettleInvoiceResp)(nil), "invoicerpc.SettleInvoiceResp")
	proto.RegisterType((*CancelInvoiceMsg)(nil), "invoicerpc.CancelInvoiceMsg")
	proto.RegisterType((*CancelInvoiceResp)(nil), "invoicerpc.CancelInvoiceResp")
	proto.RegisterEnum("invoicerpc.InvoiceState", InvoiceState_name, InvoiceState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Invoices service

type InvoicesClient interface {
	// * lncli: `addinvoice`
	// AddInvoice attempts to add a new invoice to the invoice database. Any
	// duplicated invoices are rejected, therefore all invoices *must* have a
	// unique payment preimage.
	AddInvoice(ctx context.Context, in *AddInvoiceRequest, opts ...grpc.CallOption) (*AddInvoiceResponse, error)
	// * lncli: `listinvoices`
	// ListInvoices returns a list of all the invoices currently stored within the
	// database. Any active debug invoices are ignored. It has full support for
	// paginated responses, allowing users to query for specific invoices through
	// their invoice_number. This can be done by using either the first_index_offset or
	// last_index_offset fields included in the response as the index_offset of the
	// next request. The reversed flag is set by default in order to paginate
	// backwards. If you wish to paginate forwards, you must explicitly set the
	// flag to false. If none of the parameters are specified, then the last 100
	// invoices will be returned.
	ListInvoices(ctx context.Context, in *ListInvoiceRequest, opts ...grpc.CallOption) (*ListInvoiceResponse, error)
	// * lncli: `lookupinvoice`
	// LookupInvoice attempts to look up an invoice according to its payment hash.
	// The passed payment hash *must* be exactly 32 bytes, if not, an error is
	// returned.
	LookupInvoice(ctx context.Context, in *lnrpc.PaymentHash, opts ...grpc.CallOption) (*Invoice, error)
	// *
	// SubscribeInvoices returns a uni-directional stream (server -> client) for
	// notifying the client of invoice updates. The caller can optionally specify
	// a last_update_index to catch up with missed updates.
	SubscribeInvoices(ctx context.Context, in *InvoiceSubscription, opts ...grpc.CallOption) (Invoices_SubscribeInvoicesClient, error)
	// *
	// SettleInvoice settles the specified hold invoice. If lnd isn't aware of the
	// preimage yet, it needs to be supplied with this call.
	SettleInvoice(ctx context.Context, in *SettleInvoiceMsg, opts ...grpc.CallOption) (*SettleInvoiceResp, error)
	// *
	// CancelInvoice cancels the specified invoice. This can be a hold invoice
	// in the accepted state, in which case the accepted htlc(s) are canceled back
	// and the invoice moves to the canceled state. In the canceled state, no
	// further htlcs paying to this invoice are accepted.
	//
	// In this call, a regular (non-hold) invoice can be specified too. It makes
	// the invoice unpayable.
	CancelInvoice(ctx context.Context, in *CancelInvoiceMsg, opts ...grpc.CallOption) (*CancelInvoiceResp, error)
}

type invoicesClient struct {
	cc *grpc.ClientConn
}

func NewInvoicesClient(cc *grpc.ClientConn) InvoicesClient {
	return &invoicesClient{cc}
}

func (c *invoicesClient) AddInvoice(ctx context.Context, in *AddInvoiceRequest, opts ...grpc.CallOption) (*AddInvoiceResponse, error) {
	out := new(AddInvoiceResponse)
	err := grpc.Invoke(ctx, "/invoicerpc.Invoices/AddInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) ListInvoices(ctx context.Context, in *ListInvoiceRequest, opts ...grpc.CallOption) (*ListInvoiceResponse, error) {
	out := new(ListInvoiceResponse)
	err := grpc.Invoke(ctx, "/invoicerpc.Invoices/ListInvoices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) LookupInvoice(ctx context.Context, in *lnrpc.PaymentHash, opts ...grpc.CallOption) (*Invoice, error) {
	out := new(Invoice)
	err := grpc.Invoke(ctx, "/invoicerpc.Invoices/LookupInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) SubscribeInvoices(ctx context.Context, in *InvoiceSubscription, opts ...grpc.CallOption) (Invoices_SubscribeInvoicesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Invoices_serviceDesc.Streams[0], c.cc, "/invoicerpc.Invoices/SubscribeInvoices", opts...)
	if err != nil {
		return nil, err
	}
	x := &invoicesSubscribeInvoicesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Invoices_SubscribeInvoicesClient interface {
	Recv() (*InvoiceEvent, error)
	grpc.ClientStream
}

type invoicesSubscribeInvoicesClient struct {
	grpc.ClientStream
}

func (x *invoicesSubscribeInvoicesClient) Recv() (*InvoiceEvent, error) {
	m := new(InvoiceEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *invoicesClient) SettleInvoice(ctx context.Context, in *SettleInvoiceMsg, opts ...grpc.CallOption) (*SettleInvoiceResp, error) {
	out := new(SettleInvoiceResp)
	err := grpc.Invoke(ctx, "/invoicerpc.Invoices/SettleInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicesClient) CancelInvoice(ctx context.Context, in *CancelInvoiceMsg, opts ...grpc.CallOption) (*CancelInvoiceResp, error) {
	out := new(CancelInvoiceResp)
	err := grpc.Invoke(ctx, "/invoicerpc.Invoices/CancelInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Invoices service

type InvoicesServer interface {
	// * lncli: `addinvoice`
	// AddInvoice attempts to add a new invoice to the invoice database. Any
	// duplicated invoices are rejected, therefore all invoices *must* have a
	// unique payment preimage.
	AddInvoice(context.Context, *AddInvoiceRequest) (*AddInvoiceResponse, error)
	// * lncli: `listinvoices`
	// ListInvoices returns a list of all the invoices currently stored within the
	// database. Any active debug invoices are ignored. It has full support for
	// paginated responses, allowing users to query for specific invoices through
	// their invoice_number. This can be done by using either the first_index_offset or
	// last_index_offset fields included in the response as the index_offset of the
	// next request. The reversed flag is set by default in order to paginate
	// backwards. If you wish to paginate forwards, you must explicitly set the
	// flag to false. If none of the parameters are specified, then the last 100
	// invoices will be returned.
	ListInvoices(context.Context, *ListInvoiceRequest) (*ListInvoiceResponse, error)
	// * lncli: `lookupinvoice`
	// LookupInvoice attempts to look up an invoice according to its payment hash.
	// The passed payment hash *must* be exactly 32 bytes, if not, an error is
	// returned.
	LookupInvoice(context.Context, *lnrpc.PaymentHash) (*Invoice, error)
	// *
	// SubscribeInvoices returns a uni-directional stream (server -> client) for
	// notifying the client of invoice updates. The caller can optionally specify
	// a last_update_index to catch up with missed updates.
	SubscribeInvoices(*InvoiceSubscription, Invoices_SubscribeInvoicesServer) error
	// *
	// SettleInvoice settles the specified hold invoice. If lnd isn't aware of the
	// preimage yet, it needs to be supplied with this call.
	SettleInvoice(context.Context, *SettleInvoiceMsg) (*SettleInvoiceResp, error)
	// *
	// CancelInvoice cancels the specified invoice. This can be a hold invoice
	// in the accepted state, in which case the accepted htlc(s) are canceled back
	// and the invoice moves to the canceled state. In the canceled state, no
	// further htlcs paying to this invoice are accepted.
	//
	// In this call, a regular (non-hold) invoice can be specified too. It makes
	// the invoice unpayable.
	CancelInvoice(context.Context, *CancelInvoiceMsg) (*CancelInvoiceResp, error)
}

func RegisterInvoicesServer(s *grpc.Server, srv InvoicesServer) {
	s.RegisterService(&_Invoices_serviceDesc, srv)
}

func _Invoices_AddInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).AddInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/invoicerpc.Invoices/AddInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).AddInvoice(ctx, req.(*AddInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_ListInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).ListInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/invoicerpc.Invoices/ListInvoices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).ListInvoices(ctx, req.(*ListInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_LookupInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(lnrpc.PaymentHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).LookupInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/invoicerpc.Invoices/LookupInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).LookupInvoice(ctx, req.(*lnrpc.PaymentHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_SubscribeInvoices_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InvoiceSubscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InvoicesServer).SubscribeInvoices(m, &invoicesSubscribeInvoicesServer{stream})
}

type Invoices_SubscribeInvoicesServer interface {
	Send(*InvoiceEvent) error
	grpc.ServerStream
}

type invoicesSubscribeInvoicesServer struct {
	grpc.ServerStream
}

func (x *invoicesSubscribeInvoicesServer) Send(m *InvoiceEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _Invoices_SettleInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettleInvoiceMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).SettleInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/invoicerpc.Invoices/SettleInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).SettleInvoice(ctx, req.(*SettleInvoiceMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoices_CancelInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelInvoiceMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicesServer).CancelInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/invoicerpc.Invoices/CancelInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicesServer).CancelInvoice(ctx, req.(*CancelInvoiceMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Invoices_serviceDesc = grpc.ServiceDesc{
	ServiceName: "invoicerpc.Invoices",
	HandlerType: (*InvoicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddInvoice",
			Handler:    _Invoices_AddInvoice_Handler,
		},
		{
			MethodName: "ListInvoices",
			Handler:    _Invoices_ListInvoices_Handler,
		},
		{
			MethodName: "LookupInvoice",
			Handler:    _Invoices_LookupInvoice_Handler,
		},
		{
			MethodName: "SettleInvoice",
			Handler:    _Invoices_SettleInvoice_Handler,
		},
		{
			MethodName: "CancelInvoice",
			Handler:    _Invoices_CancelInvoice_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeInvoices",
			Handler:       _Invoices_SubscribeInvoices_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "invoicerpc/invoice.proto",
}

func init() { proto.RegisterFile("invoicerpc/invoice.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 967 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xd1, 0x6e, 0xeb, 0x44,
	0x10, 0xad, 0x93, 0xb4, 0x75, 0xc6, 0x4e, 0x6f, 0xba, 0x05, 0x64, 0x05, 0xee, 0x6d, 0xf0, 0x15,
	0x22, 0xaa, 0x50, 0x02, 0x45, 0xbc, 0xf0, 0x16, 0x25, 0x91, 0x6e, 0xa5, 0xb6, 0x04, 0xb7, 0x3c,
	0x5b, 0x1b, 0x7b, 0x9b, 0x58, 0xb5, 0xd7, 0x66, 0x77, 0x13, 0x5a, 0xf1, 0x3b, 0xbc, 0xf2, 0xc2,
	0xd7, 0xf0, 0x13, 0xfc, 0x03, 0xda, 0xf5, 0x26, 0xb1, 0x13, 0x97, 0x4b, 0xdf, 0x76, 0xcf, 0x8c,
	0x67, 0x66, 0xcf, 0x9c, 0x99, 0x04, 0x9c, 0x88, 0xae, 0xd2, 0x28, 0x20, 0x2c, 0x0b, 0x06, 0xfa,
	0xd8, 0xcf, 0x58, 0x2a, 0x52, 0x04, 0x5b, 0x4b, 0x67, 0x30, 0x8f, 0xc4, 0x62, 0x39, 0xeb, 0x07,
	0x69, 0x32, 0x88, 0xa3, 0xf9, 0x42, 0xd0, 0x88, 0xce, 0x29, 0x11, 0xbf, 0xa5, 0xec, 0x71, 0x10,
	0xd3, 0x70, 0x10, 0x53, 0x19, 0x80, 0x65, 0x41, 0xfe, 0xb1, 0xfb, 0x57, 0x0d, 0x4e, 0x87, 0x61,
	0x78, 0x95, 0x87, 0xf0, 0xc8, 0xaf, 0x4b, 0xc2, 0x05, 0x42, 0xd0, 0x48, 0x48, 0x92, 0x3a, 0x46,
	0xd7, 0xe8, 0x35, 0x3d, 0x75, 0x96, 0xd8, 0x22, 0x8d, 0x43, 0xa7, 0xd6, 0x35, 0x7a, 0xa6, 0xa7,
	0xce, 0xe8, 0x2d, 0x00, 0xf3, 0x33, 0x46, 0xa2, 0x04, 0xcf, 0x89, 0x53, 0xef, 0x1a, 0x3d, 0xdb,
	0x6b, 0xb2, 0xa9, 0x06, 0xd0, 0xa7, 0x70, 0xc4, 0xfc, 0x05, 0xe6, 0x0b, 0xa7, 0xa1, 0x4c, 0x87,
	0xec, 0x03, 0xe6, 0x0b, 0xf4, 0x09, 0x1c, 0xae, 0x70, 0xbc, 0x24, 0xce, 0x61, 0xd7, 0xe8, 0xd5,
	0xbd, 0xfc, 0x82, 0x3e, 0x83, 0x23, 0xf2, 0x94, 0x45, 0xec, 0xd9, 0x39, 0x52, 0xb0, 0xbe, 0xa1,
	0xf7, 0xd0, 0x7a, 0xc0, 0x71, 0x3c, 0xc3, 0xc1, 0xa3, 0x8f, 0xc3, 0x90, 0x39, 0xc7, 0xaa, 0x28,
	0x7b, 0x0d, 0x0e, 0xc3, 0x90, 0xa1, 0x73, 0xb0, 0x82, 0x58, 0xac, 0x7c, 0x1d, 0xc1, 0xec, 0x1a,
	0xbd, 0x86, 0x07, 0x12, 0x9a, 0xe4, 0x51, 0xbe, 0x03, 0x8b, 0xa5, 0x4b, 0x41, 0xfc, 0x45, 0x44,
	0x05, 0x77, 0x9a, 0xdd, 0x7a, 0xcf, 0xba, 0x6c, 0xf7, 0x15, 0x1d, 0x7d, 0x4f, 0x5a, 0x3e, 0x44,
	0x54, 0x78, 0xc0, 0xd6, 0x47, 0x8e, 0x1c, 0x38, 0xce, 0x58, 0xb4, 0xc2, 0x82, 0x38, 0xa0, 0xde,
	0xbc, 0xbe, 0xba, 0x7f, 0xd6, 0xe1, 0x58, 0x33, 0x56, 0x49, 0xd5, 0xf6, 0xdd, 0xf5, 0xca, 0x77,
	0x37, 0x8a, 0xef, 0x7e, 0x0f, 0xad, 0x80, 0x11, 0x2c, 0xa2, 0x94, 0xfa, 0xa1, 0x4c, 0x96, 0xb3,
	0x62, 0xaf, 0xc1, 0x31, 0x16, 0x04, 0x7d, 0x0d, 0x6f, 0x32, 0xfc, 0x9c, 0x10, 0x2a, 0x7c, 0x96,
	0xf7, 0x48, 0xd3, 0x70, 0xa2, 0xe1, 0x75, 0xe7, 0xb6, 0x2c, 0x9a, 0xff, 0xcd, 0x62, 0xf3, 0xe3,
	0x2c, 0xc2, 0xc7, 0x58, 0xb4, 0x5e, 0xc7, 0xa2, 0x5d, 0x62, 0x11, 0x7d, 0x05, 0x27, 0x5a, 0xb9,
	0x3e, 0x5d, 0x26, 0x33, 0xc2, 0x9c, 0x96, 0x4a, 0xd8, 0xd2, 0xe8, 0xad, 0x02, 0xd1, 0x10, 0xec,
	0xf0, 0x99, 0xe2, 0x24, 0x0a, 0x24, 0x3d, 0xd8, 0x39, 0xe9, 0x1a, 0x3d, 0xeb, 0xf2, 0x5d, 0x7f,
	0xab, 0xfa, 0xbe, 0xee, 0xc5, 0x38, 0x77, 0x1b, 0x63, 0x81, 0x3d, 0x2b, 0xdc, 0x5e, 0xdc, 0x27,
	0xb0, 0xb5, 0xcb, 0x64, 0x45, 0xa8, 0xa8, 0xc8, 0x6c, 0xfc, 0x9f, 0xcc, 0xb5, 0xd7, 0x67, 0xfe,
	0xc7, 0x00, 0xb4, 0xef, 0x83, 0xfa, 0x70, 0xc8, 0x85, 0xa4, 0x44, 0xe6, 0x3d, 0xb9, 0x74, 0x2a,
	0x42, 0xde, 0x49, 0xbb, 0x97, 0xbb, 0xed, 0xcc, 0x59, 0x6d, 0x77, 0xce, 0xce, 0xc1, 0xe2, 0x44,
	0x88, 0x98, 0xe4, 0x02, 0xaa, 0xab, 0xce, 0x43, 0x0e, 0x29, 0xf9, 0x7c, 0x09, 0xf6, 0x32, 0x93,
	0x36, 0x3f, 0xa2, 0x21, 0x79, 0x52, 0x02, 0x6c, 0x78, 0x56, 0x8e, 0x5d, 0x49, 0x08, 0x75, 0xc1,
	0xc6, 0x89, 0xf0, 0x33, 0x1c, 0x85, 0x3e, 0xc7, 0x42, 0xab, 0x10, 0x70, 0x22, 0xa6, 0x38, 0x0a,
	0xef, 0xb0, 0x40, 0x2e, 0xb4, 0x36, 0x1e, 0x89, 0x74, 0xc9, 0xe7, 0xd4, 0xd2, 0x2e, 0x37, 0x1c,
	0x0b, 0xf7, 0x77, 0x40, 0xc5, 0x6d, 0xc2, 0xb3, 0x94, 0xf2, 0xe2, 0x1e, 0x30, 0x8a, 0xf3, 0x50,
	0x21, 0xea, 0x5a, 0xa5, 0xa8, 0xf7, 0xfb, 0x55, 0xaf, 0xe8, 0x97, 0xfb, 0x87, 0x01, 0xe8, 0x3a,
	0xe2, 0x62, 0x67, 0x99, 0xb9, 0x60, 0x67, 0x84, 0x86, 0x11, 0x9d, 0xfb, 0x29, 0x8d, 0x9f, 0x55,
	0x0d, 0xa6, 0x57, 0xc2, 0xa4, 0x8f, 0x62, 0xc6, 0x4f, 0x1f, 0x1e, 0x38, 0x11, 0x9a, 0xa0, 0x12,
	0x86, 0x2e, 0xa0, 0x4d, 0x97, 0x89, 0x9f, 0xe0, 0x27, 0x5f, 0xe7, 0xe5, 0x8a, 0xa5, 0x86, 0xb7,
	0x87, 0xa3, 0x0e, 0x98, 0x8c, 0xac, 0x08, 0xe3, 0x24, 0x54, 0x34, 0x99, 0xde, 0xe6, 0x2e, 0xcb,
	0x3c, 0x2b, 0x95, 0xa9, 0x59, 0x1a, 0x80, 0xb9, 0x89, 0x6b, 0xa8, 0xc9, 0x3a, 0xab, 0xd0, 0x85,
	0xb7, 0x71, 0x42, 0xdf, 0xc0, 0x69, 0x8c, 0xb9, 0xf0, 0x4b, 0x95, 0xd7, 0x54, 0x45, 0xfb, 0x06,
	0xd4, 0x07, 0xf4, 0x10, 0xb1, 0x5d, 0xf7, 0x9c, 0xc8, 0x0a, 0x8b, 0x3b, 0x84, 0xb3, 0xb5, 0x14,
	0x97, 0x33, 0x1e, 0xb0, 0x28, 0x93, 0xdb, 0x08, 0x5d, 0xe8, 0xa4, 0x25, 0x3d, 0xe5, 0xe3, 0xf3,
	0x46, 0x1a, 0x7e, 0xd9, 0x6a, 0xca, 0xf5, 0xa0, 0x7d, 0xa7, 0x44, 0xa8, 0x03, 0xdd, 0xf0, 0xb9,
	0x94, 0xe2, 0xba, 0xe9, 0x05, 0x45, 0x58, 0x1a, 0x53, 0xba, 0xf8, 0x1c, 0x9a, 0x19, 0x23, 0x7e,
	0x51, 0xec, 0x66, 0xc6, 0xc8, 0x95, 0xbc, 0xbb, 0x67, 0x70, 0x5a, 0x8a, 0x29, 0xe9, 0x73, 0x7f,
	0x80, 0xf6, 0x08, 0xd3, 0x80, 0xc4, 0xaf, 0x4a, 0x24, 0x63, 0x95, 0x3e, 0x93, 0xb1, 0x2e, 0x86,
	0x9b, 0x65, 0xa1, 0x46, 0x10, 0x99, 0xd0, 0xf8, 0x69, 0x3a, 0xb9, 0x6d, 0x1f, 0x20, 0x1b, 0xcc,
	0xe1, 0x68, 0x34, 0x99, 0xde, 0x4f, 0xc6, 0x6d, 0x03, 0x59, 0x70, 0x7c, 0x37, 0xb9, 0xbf, 0xbf,
	0x9e, 0x8c, 0xdb, 0x35, 0x69, 0x1a, 0x0d, 0x6f, 0x47, 0x13, 0x79, 0xab, 0x5f, 0xfe, 0x5d, 0x07,
	0xf3, 0x6a, 0xdd, 0xa5, 0x1b, 0x80, 0xed, 0x48, 0xa0, 0xb7, 0xc5, 0x96, 0xee, 0xfd, 0xf0, 0x76,
	0xde, 0xbd, 0x64, 0xce, 0x35, 0xe2, 0x1e, 0xa0, 0x9f, 0xc1, 0x2e, 0x88, 0x87, 0xa3, 0xd2, 0x17,
	0xfb, 0xea, 0xef, 0x9c, 0xbf, 0x68, 0xdf, 0x84, 0xfc, 0x11, 0x5a, 0xd7, 0x69, 0xfa, 0xb8, 0xcc,
	0x36, 0xbf, 0x69, 0x7a, 0xa3, 0x4f, 0xb7, 0x5c, 0x75, 0xaa, 0xb4, 0xe8, 0x1e, 0x20, 0x0f, 0x4e,
	0xb5, 0x3c, 0x66, 0x64, 0x53, 0xd3, 0x79, 0xd5, 0x3e, 0x2b, 0x88, 0xa8, 0x53, 0xb5, 0xf0, 0xd4,
	0x6a, 0x76, 0x0f, 0xbe, 0x35, 0xd0, 0x35, 0xb4, 0x4a, 0x2d, 0x46, 0x5f, 0x14, 0xdd, 0x77, 0x15,
	0xd5, 0x79, 0xfb, 0xa2, 0x55, 0xbe, 0x51, 0x46, 0x2b, 0x35, 0xb9, 0x1c, 0x6d, 0x57, 0x36, 0xe5,
	0x68, 0x7b, 0xea, 0x98, 0x1d, 0xa9, 0xbf, 0x4d, 0xdf, 0xff, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xc8,
	0x9f, 0x81, 0x0d, 0x8f, 0x09, 0x00, 0x00,
}
